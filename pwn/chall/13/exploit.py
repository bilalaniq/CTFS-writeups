import socket
import time

# The same "hand" arrays as in the C code
hands = ["rock", "paper", "scissors"]
loses = ["paper", "scissors", "rock"]

HOST = "saturn.picoctf.net"
PORT = 54406

def predict_computer_move(round_num):
    # Since srand is seeded with time(0), just use time.time() rounded to nearest second
    seed = int(time.time()) + round_num  # small offset to improve sync
    return seed % 3

def counter_move(computer_move):
    return loses[computer_move]

def read_until(s, expected_prompt):
    data = b""
    while expected_prompt.encode() not in data:
        chunk = s.recv(1024)
        if not chunk:
            break
        data += chunk
    print(data.decode())
    return data

def main():
    s = socket.create_connection((HOST, PORT))

    read_until(s, "Type '1' to play a game")
    wins = 0

    for round_num in range(5):
        # Send menu choice
        s.sendall(b"1\n")
        read_until(s, "Please make your selection")

        # Predict computer move
        predicted = predict_computer_move(round_num)
        my_move = counter_move(predicted)
        print(f"[Round {round_num + 1}] Predicted computer move: {predicted} => Sending: {my_move}")

        s.sendall(my_move.encode() + b"\n")
        read_until(s, "Type '1' to play a game")  # Wait for next menu prompt
        wins += 1

    # After 5 wins, flag will be shown
    s.sendall(b"1\n")
    read_until(s, "Please make your selection")

    predicted = predict_computer_move(5)
    my_move = counter_move(predicted)
    print(f"[Round 6] Predicted computer move: {predicted} => Sending: {my_move}")
    s.sendall(my_move.encode() + b"\n")

    # âœ… Capture final response with flag
    print(s.recv(4096).decode())
    try:
        print(s.recv(4096).decode())  # in case flag is in next buffer
    except:
        pass

    s.close()

if __name__ == "__main__":
    main()
